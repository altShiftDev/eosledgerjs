{"version":3,"sources":["../src/Str.js"],"names":["CLA","INS_GET_PK","INS_SIGN_TX","INS_GET_CONF","INS_SIGN_TX_HASH","INS_KEEP_ALIVE","APDU_MAX_SIZE","P1_FIRST_APDU","P1_MORE_APDU","P2_LAST_APDU","P2_MORE_APDU","SW_OK","SW_CANCEL","SW_UNKNOWN_OP","SW_MULTI_OP","SW_NOT_ALLOWED","SW_UNSUPPORTED","SW_KEEP_ALIVE","TX_MAX_SIZE","Str","transport","decorateAppAPIMethods","send","then","multiOpsEnabled","response","version","path","boolValidate","boolDisplay","apdus","pathElts","buffer","Buffer","length","forEach","element","index","writeUInt32BE","verifyMsg","from","push","concat","keepAlive","data","status","apduResponse","slice","readUInt16BE","alloc","offset","rawPublicKey","publicKey","signature","Error","transaction","bufferSize","chunkSize","chunk","copy","remaining","i","signHash_private","hash"],"mappings":"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","file":"Str.js","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2017-2018 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport {\n  splitPath,\n  foreach,\n  encodeEd25519PublicKey,\n  verifyEd25519Signature,\n  checkStellarBip32Path,\n  hash\n} from \"./utils\";\n\nconst CLA = 0xe0;\nconst INS_GET_PK = 0x02;\nconst INS_SIGN_TX = 0x04;\nconst INS_GET_CONF = 0x06;\nconst INS_SIGN_TX_HASH = 0x08;\nconst INS_KEEP_ALIVE = 0x10;\n\nconst APDU_MAX_SIZE = 150;\nconst P1_FIRST_APDU = 0x00;\nconst P1_MORE_APDU = 0x80;\nconst P2_LAST_APDU = 0x00;\nconst P2_MORE_APDU = 0x80;\n\nconst SW_OK = 0x9000;\nconst SW_CANCEL = 0x6985;\nconst SW_UNKNOWN_OP = 0x6c24;\nconst SW_MULTI_OP = 0x6c25;\nconst SW_NOT_ALLOWED = 0x6c66;\nconst SW_UNSUPPORTED = 0x6d00;\nconst SW_KEEP_ALIVE = 0x6e02;\n\nconst TX_MAX_SIZE = 1540;\n\n/**\n * Stellar API\n *\n * @example\n * import Str from \"@ledgerhq/hw-app-str\";\n * const str = new Str(transport)\n */\nexport default class Str {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>) {\n    this.transport = transport;\n    transport.decorateAppAPIMethods(\n      this,\n      [\"getAppConfiguration\", \"getPublicKey\", \"signTransaction\", \"signHash\"],\n      \"l0v\"\n    );\n  }\n\n  getAppConfiguration(): Promise<{\n    version: string\n  }> {\n    return this.transport.send(CLA, INS_GET_CONF, 0x00, 0x00).then(response => {\n      let multiOpsEnabled = response[0] === 0x01 || response[1] < 0x02;\n      let version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n      return {\n        version: version,\n        multiOpsEnabled: multiOpsEnabled\n      };\n    });\n  }\n\n  /**\n   * get Stellar public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolValidate optionally enable key pair validation\n   * @option boolDisplay optionally enable or not the display\n   * @return an object with the publicKey\n   * @example\n   * str.getPublicKey(\"44'/148'/0'\").then(o => o.publicKey)\n   */\n  getPublicKey(\n    path: string,\n    boolValidate?: boolean,\n    boolDisplay?: boolean\n  ): Promise<{ publicKey: string }> {\n    checkStellarBip32Path(path);\n\n    let apdus = [];\n    let response;\n\n    let pathElts = splitPath(path);\n    let buffer = new Buffer(1 + pathElts.length * 4);\n    buffer[0] = pathElts.length;\n    pathElts.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    let verifyMsg = Buffer.from(\"via lumina\", \"ascii\");\n    apdus.push(Buffer.concat([buffer, verifyMsg]));\n    let keepAlive = false;\n    return foreach(apdus, data =>\n      this.transport\n        .send(\n          CLA,\n          keepAlive ? INS_KEEP_ALIVE : INS_GET_PK,\n          boolValidate ? 0x01 : 0x00,\n          boolDisplay ? 0x01 : 0x00,\n          data,\n          [SW_OK, SW_KEEP_ALIVE]\n        )\n        .then(apduResponse => {\n          let status = Buffer.from(\n            apduResponse.slice(apduResponse.length - 2)\n          ).readUInt16BE(0);\n          if (status === SW_KEEP_ALIVE) {\n            keepAlive = true;\n            apdus.push(Buffer.alloc(0));\n          }\n          response = apduResponse;\n        })\n    ).then(() => {\n      // response = Buffer.from(response, 'hex');\n      let offset = 0;\n      let rawPublicKey = response.slice(offset, offset + 32);\n      offset += 32;\n      let publicKey = encodeEd25519PublicKey(rawPublicKey);\n      if (boolValidate) {\n        let signature = response.slice(offset, offset + 64);\n        if (!verifyEd25519Signature(verifyMsg, signature, rawPublicKey)) {\n          throw new Error(\n            \"Bad signature. Keypair is invalid. Please report this.\"\n          );\n        }\n      }\n      return {\n        publicKey: publicKey\n      };\n    });\n  }\n\n  /**\n   * sign a Stellar transaction.\n   * @param path a path in BIP 32 format\n   * @param transaction signature base of the transaction to sign\n   * @return an object with the signature and the status\n   * @example\n   * str.signTransaction(\"44'/148'/0'\", signatureBase).then(o => o.signature)\n   */\n  signTransaction(\n    path: string,\n    transaction: Buffer\n  ): Promise<{ signature: Buffer }> {\n    checkStellarBip32Path(path);\n\n    if (transaction.length > TX_MAX_SIZE) {\n      throw new Error(\n        \"Transaction too large: max = \" +\n          TX_MAX_SIZE +\n          \"; actual = \" +\n          transaction.length\n      );\n    }\n\n    let apdus = [];\n    let response;\n\n    let pathElts = splitPath(path);\n    let bufferSize = 1 + pathElts.length * 4;\n    let buffer = Buffer.alloc(bufferSize);\n    buffer[0] = pathElts.length;\n    pathElts.forEach(function(element, index) {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    let chunkSize = APDU_MAX_SIZE - bufferSize;\n    if (transaction.length <= chunkSize) {\n      // it fits in a single apdu\n      apdus.push(Buffer.concat([buffer, transaction]));\n    } else {\n      // we need to send multiple apdus to transmit the entire transaction\n      let chunk = Buffer.alloc(chunkSize);\n      let offset = 0;\n      transaction.copy(chunk, 0, offset, chunkSize);\n      apdus.push(Buffer.concat([buffer, chunk]));\n      offset += chunkSize;\n      while (offset < transaction.length) {\n        let remaining = transaction.length - offset;\n        chunkSize = remaining < APDU_MAX_SIZE ? remaining : APDU_MAX_SIZE;\n        chunk = Buffer.alloc(chunkSize);\n        transaction.copy(chunk, 0, offset, offset + chunkSize);\n        offset += chunkSize;\n        apdus.push(chunk);\n      }\n    }\n    let keepAlive = false;\n    return foreach(apdus, (data, i) =>\n      this.transport\n        .send(\n          CLA,\n          keepAlive ? INS_KEEP_ALIVE : INS_SIGN_TX,\n          i === 0 ? P1_FIRST_APDU : P1_MORE_APDU,\n          i === apdus.length - 1 ? P2_LAST_APDU : P2_MORE_APDU,\n          data,\n          [SW_OK, SW_CANCEL, SW_UNKNOWN_OP, SW_MULTI_OP, SW_KEEP_ALIVE]\n        )\n        .then(apduResponse => {\n          let status = Buffer.from(\n            apduResponse.slice(apduResponse.length - 2)\n          ).readUInt16BE(0);\n          if (status === SW_KEEP_ALIVE) {\n            keepAlive = true;\n            apdus.push(Buffer.alloc(0));\n          }\n          response = apduResponse;\n        })\n    ).then(() => {\n      let status = Buffer.from(\n        response.slice(response.length - 2)\n      ).readUInt16BE(0);\n      if (status === SW_OK) {\n        let signature = Buffer.from(response.slice(0, response.length - 2));\n        return {\n          signature: signature\n        };\n      } else if (status === SW_UNKNOWN_OP) {\n        // pre-v2 app version: fall back on hash signing\n        return this.signHash_private(path, hash(transaction));\n      } else if (status === SW_MULTI_OP) {\n        // multi-operation transaction: attempt hash signing\n        return this.signHash_private(path, hash(transaction));\n      } else {\n        throw new Error(\"Transaction approval request was rejected\");\n      }\n    });\n  }\n\n  /**\n   * sign a Stellar transaction hash.\n   * @param path a path in BIP 32 format\n   * @param hash hash of the transaction to sign\n   * @return an object with the signature\n   * @example\n   * str.signHash(\"44'/148'/0'\", hash).then(o => o.signature)\n   */\n  signHash(path: string, hash: Buffer): Promise<{ signature: Buffer }> {\n    checkStellarBip32Path(path);\n    return this.signHash_private(path, hash);\n  }\n\n  signHash_private(path: string, hash: Buffer): Promise<{ signature: Buffer }> {\n    let apdus = [];\n    let response;\n\n    let pathElts = splitPath(path);\n    let buffer = Buffer.alloc(1 + pathElts.length * 4);\n    buffer[0] = pathElts.length;\n    pathElts.forEach(function(element, index) {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    apdus.push(Buffer.concat([buffer, hash]));\n    let keepAlive = false;\n    return foreach(apdus, data =>\n      this.transport\n        .send(\n          CLA,\n          keepAlive ? INS_KEEP_ALIVE : INS_SIGN_TX_HASH,\n          0x00,\n          0x00,\n          data,\n          [SW_OK, SW_CANCEL, SW_NOT_ALLOWED, SW_UNSUPPORTED, SW_KEEP_ALIVE]\n        )\n        .then(apduResponse => {\n          let status = Buffer.from(\n            apduResponse.slice(apduResponse.length - 2)\n          ).readUInt16BE(0);\n          if (status === SW_KEEP_ALIVE) {\n            keepAlive = true;\n            apdus.push(Buffer.alloc(0));\n          }\n          response = apduResponse;\n        })\n    ).then(() => {\n      let status = Buffer.from(\n        response.slice(response.length - 2)\n      ).readUInt16BE(0);\n      if (status === SW_OK) {\n        let signature = Buffer.from(response.slice(0, response.length - 2));\n        return {\n          signature: signature\n        };\n      } else if (status === SW_CANCEL) {\n        throw new Error(\"Transaction approval request was rejected\");\n      } else if (status === SW_UNSUPPORTED) {\n        throw new Error(\"Hash signing is not supported\");\n      } else {\n        throw new Error(\n          \"Hash signing not allowed. Have you enabled it in the app settings?\"\n        );\n      }\n    });\n  }\n}\n"]}